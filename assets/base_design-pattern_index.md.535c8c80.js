import{_ as s,c as n,o as a,Q as l}from"./chunks/framework.f14b72c3.js";const C=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"base/design-pattern/index.md","lastUpdated":1685193505000}'),p={name:"base/design-pattern/index.md"},o=l(`<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><p><img src="https://zghimg.oss-cn-beijing.aliyuncs.com/blog/1666418201.png" alt="image"></p><h2 id="solid-设计原则" tabindex="-1">SOLID 设计原则 <a class="header-anchor" href="#solid-设计原则" aria-label="Permalink to &quot;SOLID 设计原则&quot;">​</a></h2><blockquote><p>&quot;SOLID&quot; 是由罗伯特·C·马丁在 21 世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。</p></blockquote><ul><li>单一功能原则（Single Responsibility Principle）</li><li>开放封闭原则（Opened Closed Principle）</li><li>里式替换原则（Liskov Substitution Principle）</li><li>接口隔离原则（Interface Segregation Principle）</li><li>依赖反转原则（Dependency Inversion Principle）</li></ul><h2 id="核心思想" tabindex="-1">核心思想 <a class="header-anchor" href="#核心思想" aria-label="Permalink to &quot;核心思想&quot;">​</a></h2><p>封装变化，<strong>将变与不变分离，确保变化的部分灵活、不变的部分稳定</strong></p><h2 id="构造器模式" tabindex="-1">构造器模式 <a class="header-anchor" href="#构造器模式" aria-label="Permalink to &quot;构造器模式&quot;">​</a></h2><p>如果想创建两个对象，可能会用如下方式：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dracula"><code><span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> person1 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> { name</span><span style="color:#FF79C6;">:</span><span style="color:#F8F8F2;"> </span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">zgh</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">, age</span><span style="color:#FF79C6;">:</span><span style="color:#F8F8F2;"> </span><span style="color:#BD93F9;">23</span><span style="color:#F8F8F2;"> }</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> person2 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> { name</span><span style="color:#FF79C6;">:</span><span style="color:#F8F8F2;"> </span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">lrx</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">, age</span><span style="color:#FF79C6;">:</span><span style="color:#F8F8F2;"> </span><span style="color:#BD93F9;">22</span><span style="color:#F8F8F2;"> }</span></span>
<span class="line"></span></code></pre></div><p>但是创建很多个这种对象，就会很费事，采用构造器模式就能轻松解决</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dracula"><code><span class="line"><span style="color:#FF79C6;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">createObj</span><span style="color:#F8F8F2;">(</span><span style="color:#FFB86C;font-style:italic;">name</span><span style="color:#F8F8F2;">, </span><span style="color:#FFB86C;font-style:italic;">age</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#BD93F9;font-style:italic;">this</span><span style="color:#F8F8F2;">.name </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> name</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#BD93F9;font-style:italic;">this</span><span style="color:#F8F8F2;">.age </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> age</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> person1 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;font-weight:bold;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">createObj</span><span style="color:#F8F8F2;">(</span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">zgh</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">23</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> person2 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;font-weight:bold;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">createObj</span><span style="color:#F8F8F2;">(</span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">lrx</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">22</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"></span></code></pre></div><p>这里变的是每个人的姓名、年龄这些值，这是人的<strong>个性</strong>，不变的是每个人都具备姓名、年龄这些属性，这是人的<strong>共性</strong>。</p><p>构造器就是将 name、age 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 name、age 各自的取值操作开放，确保了个性的灵活</p><h2 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h2><p>单例模式，<strong>保证一个类仅有一个实例，并提供一个全局访问点</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dracula"><code><span class="line"><span style="color:#FF79C6;">class</span><span style="color:#F8F8F2;"> </span><span style="color:#8BE9FD;">SingleDog</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#50FA7B;">show</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#50FA7B;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">一个单例对象</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> s1 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;font-weight:bold;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">SingleDog</span><span style="color:#F8F8F2;">()</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> s2 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;font-weight:bold;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">SingleDog</span><span style="color:#F8F8F2;">()</span></span>
<span class="line"></span></code></pre></div><p>上面的实例 s1、s2 是相互独立的对象，而单例模式则是无论创建多少次，都返回第一次创建的唯一的实例。 需要构造函数<strong>具备判断自己是否已经构造过一个实例</strong>的能力。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dracula"><code><span class="line"><span style="color:#FF79C6;">class</span><span style="color:#F8F8F2;"> </span><span style="color:#8BE9FD;">SingDog</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#50FA7B;">show</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#50FA7B;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">单例对象</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#FF79C6;">static</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">getInstance</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FF79C6;">if</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">!</span><span style="color:#F8F8F2;">SingDog.instance) {</span></span>
<span class="line"><span style="color:#F8F8F2;">      SingDog.instance </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;font-weight:bold;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">SingDog</span><span style="color:#F8F8F2;">()</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FF79C6;">return</span><span style="color:#F8F8F2;"> SingDog.instance</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> s1 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> SingDog.</span><span style="color:#50FA7B;">getInstance</span><span style="color:#F8F8F2;">()</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#F8F8F2;"> s2 </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> SingDog.</span><span style="color:#50FA7B;">getInstance</span><span style="color:#F8F8F2;">()</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#50FA7B;">log</span><span style="color:#F8F8F2;">(s1 </span><span style="color:#FF79C6;">===</span><span style="color:#F8F8F2;"> s2) </span><span style="color:#6272A4;">// true</span></span>
<span class="line"></span></code></pre></div><p>上面使用静态方法，还可以使用闭包，都指向唯一的实例</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dracula"><code><span class="line"><span style="color:#F8F8F2;">SingDog.getInstance </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> instance </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#BD93F9;">null</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#FF79C6;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FF79C6;">if</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">!</span><span style="color:#F8F8F2;">instance) {</span></span>
<span class="line"><span style="color:#F8F8F2;">      instance </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#FF79C6;font-weight:bold;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#50FA7B;">SingDog</span><span style="color:#F8F8F2;">()</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FF79C6;">return</span><span style="color:#F8F8F2;"> instance</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#F8F8F2;">})()</span></span>
<span class="line"></span></code></pre></div>`,21),F=[o];function e(t,c,r,y,i,g){return a(),n("div",null,F)}const u=s(p,[["render",e]]);export{C as __pageData,u as default};
